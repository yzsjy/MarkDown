# 春招面试重点知识点总结

## Java基础

### 重载和重写

重写多用于子类继承父类的方法，并对父类的方法进行了重新构造。返回值、参数列表和方法名必须完全相同，私有方法、final、static不可被重写，构造方法不可以被重写。

重载通俗来讲就是在相同的方法名下，有着不同的参数列表，即可以视为重载。

| 区别点     | 重载方法 | 重写方法                       |
| ---------- | -------- | ------------------------------ |
| 发生范围   | 同一个类 | 子类                           |
| 参数列表   | 必须修改 | 不能修改                       |
| 返回类型   | 可以修改 | 比父类范围更小或者相同         |
| 异常       | 可以修改 | 比父类范围更小或者相同         |
| 访问修饰符 | 可以修改 | 一定不能做严格限制，可降低限制 |
| 发生阶段   | 编译期   | 运行期                         |



### String, StringBuffer和StringBuilder的区别？String为什么是不可变的？

String类是使用final修饰的字符数组来表示字符串的，`private final char value[]`，所以String对象是不可变的。

StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder类中都是使用字符数组来保存字符串的，但没有final关键字修饰，所以这两个是可变的。

由于String是不可变的，所以是线程安全的。StringBuffer对方法或者调用的方法添加了同步锁，所以是线程安全的，而StringBuilder没有添加同步锁，所以不是线程安全的。

每次对String类型进行改变时都会生成一个新的String对象，而StringBuilder和StringBuffer都是在自身进行操作。

## JVM虚拟机

### Java对象创建过程

#### Step 1 类加载检查

虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先进行相应的类加载过程。

#### Step 2 分配内存

在类加载检查过后，接下来虚拟机为新创建的对象分配内存，所需大小在类加载过后就可以确认。为对象分配内存等同于将确定大小的内存从Java堆中取出来。分配方式有“指针碰撞”和“空闲列表”，选择哪种方式由Java堆是否规整决定，而Java堆是否规整由虚拟机采用的垃圾收集器是否带有压缩整理的功能决定。

内存分配的两种方式（指针碰撞和空闲列表）

|          | 指针碰撞                                                     | 空闲列表                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 适用场合 | 堆内存规整（即没有内存碎片）                                 | 堆内存不规整                                                 |
| 原理     | 用过的内存全部整理到一边，没用过的内存放在另一边，中间有一个分界指针，只需要向着没用到的内存方向将该指针移动到创建对象所需大小的位置就好 | 虚拟机会维护一个列表，该列表会记录哪个内存块是可用的，在分配的时候选取一块比所需内存大的块就好，最后更新列表 |
| GC收集器 | Serial，ParNew                                               | CMS                                                          |

内存分配并发问题

创建对象很重要的一件事是保证线程安全，通常采用两种方式来保证线程安全

CAS+失败重试：CAS是乐观锁的一种实现方式。每次不加锁而是假设完成操作时没有冲突，若发生冲突就失败重试，直到成功为止。这种方式保证了更新操作的原子性

TLAB：为每个线程预先在Eden区分配一块内存，JVM在给线程对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB中内存用尽时，在采取上述的CAS进行内存分配

#### Step 3 初始化零值

内存分配完成后，虚拟机需要将分配的内存空间初始化为零值（不包括对象头），这一步操作保证了对象在Java代码中不初始化就能直接使用，程序能够访问到这些字段的数据类型所对应的零值。

#### Step 4 设置对象头

初始化零值完成后，虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行的状态不同，如是否使用偏向锁等，对象头会有不同的设置方式。

#### Step 5 执行init方法

在上面工作都完成以后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚开始，<init>方法还没有执行，所有的字段都还是零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这时一个真正可用的对象才算完全产生出来。

## 计算机网络

### 网络层

#### IP数据报

![](/Users/yzsjy/Desktop/MarkDown/Picture/IP数据报.jpg)

**版本**：指IP的版本

**首部长度**：占4位

**总长度**：占16位，指首部和数据之和的长度，这个长度不能超过数据链路层的以太网帧的最大传送值（MTU）

**标识**：占16位，每产生一个数据报时就加1，数据报产生分片时要复制标识到每个分片

**标志**：占3位，最低位为MF，MF=1时表示后面还有分片，MF=0时表示为最后一个分片，中间位为DF，只有DF=0时才允许分片

**片偏移**：占13位，以8个字节为偏移单位，主要是让接收方利用片偏移将数据报分片重组

**首部校验和**：占16位，只校验首部

**生存时间（TTL）**：占8位，主要用来控制数据报经过路由的最大值，为0时要丢弃数据报

**协议**：占8位，主要告诉传输层运用哪种传输控制协议，6表示TCP，17表示UDP

**源地址字段**：占4B，表示发送方IP地址

**目的地址字段**：占4B，表示接收方IP地址



#### IP数据报分片

当一个IP数据报的最大数据量超过最大传送单元（MTU）时，就需要将IP数据报进行分片操作，分装在两个或更多的片中。片在目的地的网络层会被重新组装，利用IP数据报中的标识、标志、片偏移字段来完成对数据报的重组。



#### 网络层转发分组的流程

1. 从数据报的首部提取目的地址字段，得出目的网络地址N
2. 若网络地址N与当前路由相连，则把数据报直接交给目的地址主机，称为直接交付
3. 若路由表中有与网络地址N相连的特定路由，则将数据报交付给指明的下一跳路由
4. 若路由表没有到达N的路由，则把数据报传送给路由表指明的下一跳路由
5. 若路由表中有一个默认路由，则把数据报传送给路由表所指明的默认路由
6. 报告转发分组出错



#### IP地址的特点

每个IP地址都由网络号和主机号两部分组成，好处是IP地址管理机构只分配网络号而主机号由得到网络号的机构自行分配以及路由器只通过网络号来转发分组，从而减少了路由表所占的空间

IP地址是标志一台主机和一条链路的接口

用转发器或者桥接连接的若干LAN依然是同一个网络，因此该LAN中所有的主机IP的网络号都相同，而主机号不相同

在IP地址中，所有分配到的网络号的网络都是平等的

在同一个局域网上的主机和路由器的IP地址中的网络号必须是一样的，路由器的每个端口都有一个不同网络号的IP地址

### Https方式与服务器通信步骤

（1）客户端使用http的url访问服务端，请求与服务端建立ssl连接

（2）服务端收到建立连接请求后，将网站的证书信息（包含公钥）发送给客户端

（3）客户端与服务端协商ssl连接的安全等级，也就是信息加密等级

（4）客户端浏览器根同意的安全等级，建立会话密钥，使用服务端提供的公钥将会话密钥加密，发送给服务端

（5）服务端利用自己的私钥解析出会话密钥

（6）服务端利用会话密钥加密与客户端之间的通信



#### SSL/TLS协议建立详细过程

（1）客户端发送`clientHello`请求建立加密通信请求，包括客户端支持的SSL/TLS协议版本，客户端生产的随机数，客户端支持的加密格式

（2）服务端发送`serverHello`来响应客户端的请求，包括确认SSL/TLS的版本，若不支持则关闭连接；服务端生产的随机数，确认的加密格式以及服务端的CA数字证数

（3）客户端收到服务端的回应后，识别服务端的CA证书来确认证数是否有效，若有效则取出服务器的公钥，然后用公钥加密报文，向服务器发送

				1. 客户端随机数（经过公钥加密）
				2. 加密通信算法改变通知，即用会话密钥进行通信
				3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

（4）服务端收到客户端的协商请求后，通过协商的加密算法生成会话密钥，向客户端发送

1. 加密算法改变通知，表示以后发送信息都将采用会话密钥进行
2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验





## 操作系统

### 死锁

当两个或多于两个线程互相持有对方资源时，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才能释放资源，在此期间，其他线程不能访问代码块。当线程互相持有对方所需的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁

#### 死锁产生的条件

1. 互斥条件：进程对于所分配到的资源具有排他性，即一个资源只能被一个进程占用，直到该进程被释放
2. 请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放
3. 不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用
4. 循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路，造成永久阻塞

### Socket

socket的中文名叫作套接字，是进程通信之间里比较特殊的方式，特别之处在于可以跨主机之间通信。客户端和服务端之间进行网络通信前，各自都创建一个socket，双方读取和发送数据时都是通过这个socket。

创建socket时可以指定网络层运用ipv4还是ipv6，传输层使用tcp还是udp。服务端的socket需要先运行起来

服务端首先调用`socket()`函数，创建网络协议为ipv4和传输协议为tcp的socket；接着调用`bind()`函数，给这个socket绑定一个ip地址和端口；接着调用`listen()`函数进行监听，此时对应tcp状态图的listen，如果我们要判定服务器中一个网络程序有没有启动，可以通过`netstate`命令查看对应的端口号是否被监听；最后通过调用`accept()`函数从内核调用客户端连接，如果没有客户端的连接请求，则会阻塞等待客户端的连接到来

