# 春招面试重点知识点总结

## Java基础

### 重载和重写

重写多用于子类继承父类的方法，并对父类的方法进行了重新构造。返回值、参数列表和方法名必须完全相同，私有方法、final、static不可被重写，构造方法不可以被重写。

重载通俗来讲就是在相同的方法名下，有着不同的参数列表，即可以视为重载。

| 区别点     | 重载方法 | 重写方法                       |
| ---------- | -------- | ------------------------------ |
| 发生范围   | 同一个类 | 子类                           |
| 参数列表   | 必须修改 | 不能修改                       |
| 返回类型   | 可以修改 | 比父类范围更小或者相同         |
| 异常       | 可以修改 | 比父类范围更小或者相同         |
| 访问修饰符 | 可以修改 | 一定不能做严格限制，可降低限制 |
| 发生阶段   | 编译期   | 运行期                         |



### String, StringBuffer和StringBuilder的区别？String为什么是不可变的？

String类是使用final修饰的字符数组来表示字符串的，`private final char value[]`，所以String对象是不可变的。

StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder类中都是使用字符数组来保存字符串的，但没有final关键字修饰，所以这两个是可变的。

由于String是不可变的，所以是线程安全的。StringBuffer对方法或者调用的方法添加了同步锁，所以是线程安全的，而StringBuilder没有添加同步锁，所以不是线程安全的。

每次对String类型进行改变时都会生成一个新的String对象，而StringBuilder和StringBuffer都是在自身进行操作。

## JVM虚拟机

### Java对象引用算法

#### 引用计数算法

在对象中添加一个引用计数器，当有一个地方引用时，计数器值加一；当引用失效时，计数器值减一；计数器值为零时表示对象不可引用。该算法原理简单，判断高效，但可能不能结局例如对象之间互相循环引用的问。Java虚拟机不使用引用技术算法。

#### 可达性分析算法

该算法是当前主流程序语言判断对象存活的算法。通过一系列称为“GC Roots”的根对象作为起始结点集，从这个结点根据引用关系向下搜索，搜索过的路径称为引用链，若一个对象到GC Roots间没有任何引用链，则该对象不可在使用。

GC Roots对象可以是以下几种：

1. 虚拟机栈中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2. 在方法区中类静态属性引用的对象，例如Java类的引用类型静态变量
3. 在方法区中常量引用的对象，例如字符串常量池里的引用
4. 在本地方法栈中JNI（通常所说的Native方法）引用的对象
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NulPointException、OutOfMemeryError）等，还有系统类加载器
6. 所有被同步锁（synchronized关键字）持有的对象
7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等



### 垃圾回收

#### Full GC回收条件

当准备触发一次Young GC时，如果发现统计数据说之前Young GC的平均晋升大小比目前Old Gen剩余的空间大，则不会触发Young GC而是转而触发Full GC

如果有永久代，如果永久代分配的空间已经没有足够的空间了，也要触发一次Full GC

在调用诸如System.gc()、heap dump带GC，默认是触发Full GC

### Java对象创建过程

#### Step 1 类加载检查

虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先进行相应的类加载过程。

#### Step 2 分配内存

在类加载检查过后，接下来虚拟机为新创建的对象分配内存，所需大小在类加载过后就可以确认。为对象分配内存等同于将确定大小的内存从Java堆中取出来。分配方式有“指针碰撞”和“空闲列表”，选择哪种方式由Java堆是否规整决定，而Java堆是否规整由虚拟机采用的垃圾收集器是否带有压缩整理的功能决定。

内存分配的两种方式（指针碰撞和空闲列表）

|          | 指针碰撞                                                     | 空闲列表                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 适用场合 | 堆内存规整（即没有内存碎片）                                 | 堆内存不规整                                                 |
| 原理     | 用过的内存全部整理到一边，没用过的内存放在另一边，中间有一个分界指针，只需要向着没用到的内存方向将该指针移动到创建对象所需大小的位置就好 | 虚拟机会维护一个列表，该列表会记录哪个内存块是可用的，在分配的时候选取一块比所需内存大的块就好，最后更新列表 |
| GC收集器 | Serial，ParNew                                               | CMS                                                          |

内存分配并发问题

创建对象很重要的一件事是保证线程安全，通常采用两种方式来保证线程安全

CAS+失败重试：CAS是乐观锁的一种实现方式。每次不加锁而是假设完成操作时没有冲突，若发生冲突就失败重试，直到成功为止。这种方式保证了更新操作的原子性

TLAB：为每个线程预先在Eden区分配一块内存，JVM在给线程对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB中内存用尽时，在采取上述的CAS进行内存分配

#### Step 3 初始化零值

内存分配完成后，虚拟机需要将分配的内存空间初始化为零值（不包括对象头），这一步操作保证了对象在Java代码中不初始化就能直接使用，程序能够访问到这些字段的数据类型所对应的零值。

#### Step 4 设置对象头

初始化零值完成后，虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行的状态不同，如是否使用偏向锁等，对象头会有不同的设置方式。

#### Step 5 执行init方法

在上面工作都完成以后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚开始，<init>方法还没有执行，所有的字段都还是零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这时一个真正可用的对象才算完全产生出来。



### 类加载的时机

以下情况需要立即执行类加载

（1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行初始化，则需要先触发其初始化阶段

（2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有初始化，需要先触发其初始化

（3）当初始化类的时候，如果发现其父类还没有初始化，则需要先初始化父类

（4）当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会优先初始化这个主类

（5）当使用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化

（6）当一个接口定义了默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化



### 类加载器

启动类加载器(Bootstrap Class Loader)：最顶层的加载类，负责加载Java目录下lib文件夹的jar包和`-Xbootclasspat`h参数指定的路径中的类

扩展类加载器：加载jre中lib/ext目录下的jar包，或者被`java.ext.dirs`系统变量所指定的路径

应用程序类加载器：面向我们用户的类加载器

#### 双亲委派模型

每一个类都有对应的类加载器，在类加载过程中默认使用双亲委派模型。在类加载过程中，首先会判定当前类是否被加载过，已经被加载的类会直接返回，否则首先会把该请求委派给父类加载器的`loadClass()`处理，所有的请求最终都会传输到顶层类加载器`BootstrapClassLoader`中。当父类无法加载请求时，才会自己来处理

#### 自定义类加载

如果不想打破双亲委派模型，就重写`ClassLoader`类中的findClass()方法即可，无法被父类加载器加载的类都会通过这个方法被加载。如果需要打破双亲委派模型就需要重写`loadClass()`方法。



### GC记录

为了严格监控应用程序的运行情况，我们应该始终检查JVM的垃圾回收性能。使用以下参数，我们能够记录GC活动：

```shell
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=< number of log files >
-XX:GClogFileSize=< file size >[ unit ]
-Xloggc:/path/to/gc.log
```



## Java并发

### Synchronized和ReentrantLock

#### 锁的实现

Synchronized锁是在jvm中实现的，ReentrantLock锁是在jdk中实现的

#### 性能

新版本的Java对Synchronized锁进行了很大优化，引入了自旋锁等概念，两者性能大致相同

#### 等待可中断

当持有锁的线程长期不释放锁的时候，等待的线程可以选择放弃等待，专为执行其他事务

ReentrantLock可中断，Synchronized锁不可中断

#### 公平锁

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的顺序来获取资源

Synchronized锁是非公平的，ReentrantLock锁也是非公平的，但也可以变为公平的

#### 锁绑定多个条件

一个ReentrantLock可以同时绑定多个Condition对象

#### 使用选择

除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 **JVM** 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 **JDK** 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。



### Thread类的几个常用方法

currentThread()：静态方法，返回当前正在执行的线程对象的引用

start()：开始执行线程的方法，Java虚拟机会调用线程内的run()方法

yield()：yield在英语中有放弃的意思，这里指当前线程愿意让出当前对处理器的占用，这里注意的是即使调用该方法，也还可能继续执行该线程

sleep()：静态方法，使当前线程睡眠一段时间

join()：使当前线程等待另一个线程执行完毕后在继续执行，内部调用的是Object类的wait方法来实现的

### Thread类和Runnable接口的比较

Java“单继承，多实现”的特性，Runnable接口使用比Thread类更加灵活

Runnable接口出现更符合面向对象，将线程单独进行对象的封装

Runnable接口出现，降低了线程对象和线程任务的耦合性

如果线程不需要使用Thread类的诸多方法，显然使用Runnable接口更加轻量



### 乐观锁与悲观锁

#### 区别

悲观锁：悲观锁认为每次访问共享资源时会发生冲突，所以每次必须对数据操作加上锁，以保证临界区的程序同一时间只有一个线程在执行

乐观锁：无锁，乐观锁认为每次访问共享资源时不会发生冲突，而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全，**乐观锁天然免疫死锁**

#### CAS

Compare And Swap，比较和交换

V：要更新的变量

E：预期值

N：新值

只有V的值等于E的值，才能用N的值替换V的值，反之则当前线程放弃更新

当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并允许再次尝试，当然也允许失败的线程放弃操作



### AQS

AbstractQueuedSynchronizer，抽象队列同步器

作用：构建锁和同步器的框架，能简单高效的构造出应用广泛的同步器，比如ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等

也可以自定义同步器，只要实现子类的几个protected方法就行

#### 数据结构





## 计算机网络

### 网络层

#### IP数据报

![1](https://github.com/yzsjy/MarkDown/blob/main/image/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg)

**版本**：指IP的版本

**首部长度**：占4位

**总长度**：占16位，指首部和数据之和的长度，这个长度不能超过数据链路层的以太网帧的最大传送值（MTU）

**标识**：占16位，每产生一个数据报时就加1，数据报产生分片时要复制标识到每个分片

**标志**：占3位，最低位为MF，MF=1时表示后面还有分片，MF=0时表示为最后一个分片，中间位为DF，只有DF=0时才允许分片

**片偏移**：占13位，以8个字节为偏移单位，主要是让接收方利用片偏移将数据报分片重组

**首部校验和**：占16位，只校验首部

**生存时间（TTL）**：占8位，主要用来控制数据报经过路由的最大值，为0时要丢弃数据报

**协议**：占8位，主要告诉传输层运用哪种传输控制协议，6表示TCP，17表示UDP

**源地址字段**：占4B，表示发送方IP地址

**目的地址字段**：占4B，表示接收方IP地址



#### IP数据报分片

当一个IP数据报的最大数据量超过最大传送单元（MTU）时，就需要将IP数据报进行分片操作，分装在两个或更多的片中。片在目的地的网络层会被重新组装，利用IP数据报中的标识、标志、片偏移字段来完成对数据报的重组。



#### 网络层转发分组的流程

1. 从数据报的首部提取目的地址字段，得出目的网络地址N
2. 若网络地址N与当前路由相连，则把数据报直接交给目的地址主机，称为直接交付
3. 若路由表中有与网络地址N相连的特定路由，则将数据报交付给指明的下一跳路由
4. 若路由表没有到达N的路由，则把数据报传送给路由表指明的下一跳路由
5. 若路由表中有一个默认路由，则把数据报传送给路由表所指明的默认路由
6. 报告转发分组出错



#### IP地址的特点

每个IP地址都由网络号和主机号两部分组成，好处是IP地址管理机构只分配网络号而主机号由得到网络号的机构自行分配以及路由器只通过网络号来转发分组，从而减少了路由表所占的空间

IP地址是标志一台主机和一条链路的接口

用转发器或者桥接连接的若干LAN依然是同一个网络，因此该LAN中所有的主机IP的网络号都相同，而主机号不相同

在IP地址中，所有分配到的网络号的网络都是平等的

在同一个局域网上的主机和路由器的IP地址中的网络号必须是一样的，路由器的每个端口都有一个不同网络号的IP地址



### Http和Https

#### 区别和联系

Http是超文本传输协议，传输的是明文信息，是不安全的；Https解决了Http的不安全传输，在TCP和Http网络层之间增加了SSL/TLS安全协议，保证了传输的安全性

Http传输建立相对简单，在TCP三次握手后便可进行传输；而Https在TCP三次握手的基础上加入了SSL/TLS的握手过程

Http使用的端口号为80，Https使用的端口号为443

Https协议需要向CA申请数字证书，来保证服务器的身份是可信的

Https通过SSL/TLS协议实现了信息加密、校验机制和身份证书，很好的解决了Http的窃听风险、篡改风险和冒充风险

#### Https的加密实现

信息加密解决窃听风险：采用混合加密的形式，在通信建立以前采用非对称加密的方式交换会话密钥，在建立通信以后采用对称加密的方式，通过会话密钥对明文进行加密

校验机制解决篡改风险：摘要算法能够为数据生成独一无二的指纹，用于校验数据的完整性，解决了篡改的风险。主要流程是通过在明文加密前绑定摘要，在接收端解密密文后利用摘要算法计算出摘要与明文绑定的摘要进行对比

身份证书解决冒充风险

### Https方式与服务器通信步骤

（1）客户端使用http的url访问服务端，请求与服务端建立ssl连接

（2）服务端收到建立连接请求后，将网站的证书信息（包含公钥）发送给客户端

（3）客户端与服务端协商ssl连接的安全等级，也就是信息加密等级

（4）客户端浏览器根同意的安全等级，建立会话密钥，使用服务端提供的公钥将会话密钥加密，发送给服务端

（5）服务端利用自己的私钥解析出会话密钥

（6）服务端利用会话密钥加密与客户端之间的通信



#### SSL/TLS协议建立详细过程

（1）客户端发送`clientHello`请求建立加密通信请求，包括客户端支持的SSL/TLS协议版本，客户端生产的随机数，客户端支持的加密格式

（2）服务端发送`serverHello`来响应客户端的请求，包括确认SSL/TLS的版本，若不支持则关闭连接；服务端生产的随机数，确认的加密格式以及服务端的CA数字证数

（3）客户端收到服务端的回应后，识别服务端的CA证书来确认证数是否有效，若有效则取出服务器的公钥，然后用公钥加密报文，向服务器发送

		1. 客户端随机数（经过公钥加密）
		2. 加密通信算法改变通知，即用会话密钥进行通信
		3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

第三步结束后用双方协商的加密算法，各自生成本次通信的会话密钥

（4）服务端收到客户端的协商请求后，通过协商的加密算法生成会话密钥，向客户端发送

```
	1. 加密算法改变通知，表示以后发送信息都将采用会话密钥进行
	2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验
```

至此整个SSL/TLS握手阶段全部结束， 接下来进行加密通信，利用会话密钥来加密内容



### Http/1.1、Http/2、Http/3演变

#### Http1.1相对于Http1.0的提升

使用TCP长连接的方式改善了1.0短连接造成的性能开销

支持管道网络传输，只要第一个请求发出去不需要等待其回来，就可以发出第二个请求，减少传输整体的响应时间

**不足：**

请求/响应头部未经压缩就发送，首部信息越多延迟就越大，从而延迟大以后只能压缩body部分

每次发送相同的首部造成浪费较多

服务器的响应顺序是按照请求顺序的，如果服务器响应慢，客户端会一直请求不到数据，造成队头阻塞

没有请求优先级控制

请求只能从客户端开始，服务器只能被动响应

#### Http2相对于Http1.1的提升

首先Http2是基于Https的，所以Http2的安全是有保障的

头部压缩：如果发送多个请求，如果他们的头部是一致或者相似的，协议会帮助消除重复的部分。采用HPACK算法，在两端同时维护一个头部信息表，所有字段都会存入这个表中，生成一个索引号，每次传输只发送索引号

二进制格式：不在采用之前的报文格式，全面采用二进制格式，头部信息和数据体都是二进制，称之为帧。提高效率

数据流：Http2中数据包不是按照顺序发送的，同一个连接里的连续数据包，可能属于不同的回应。因此必须对数据包做标记，指出其属于哪个回应。

多路复用：Http2可以在一个连接中并发多个请求或回应，不用按照顺序一一对应

服务器推送：服务器可以主动向客户端发送消息。例如在浏览器请求html的时候，就会提前把可能用到的js、css文件等静态资源主动发送给客户端，减少延迟等待

**不足：**

多个Http请求复用一个TCP连接，下层的TCP协议是不知道多少Http请求的，所以一旦发生丢包，就会触发TCP的重传机制，这样所有的Http请求都必须等待这个被丢失的包被重传回来

#### Http3相对于Http2的提升

Http3把Http下层的TCP协议改成了UDP

**如何实现UDP的可靠传输：**

采用QUIC协议实现UDP的可靠传输

QUIC有自己的一套机制可以保证传输的可靠性，当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响

TLS协议升级到了最新的1.3版本，头部压缩算法也升级成QPACK

QUIC直接把以往的TCP+TLS的6次交互合并成了3次，减少了交互次数

## 操作系统

### 死锁

当两个或多于两个线程互相持有对方资源时，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才能释放资源，在此期间，其他线程不能访问代码块。当线程互相持有对方所需的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁

#### 死锁产生的条件

1. 互斥条件：进程对于所分配到的资源具有排他性，即一个资源只能被一个进程占用，直到该进程被释放
2. 请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放
3. 不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用
4. 循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路，造成永久阻塞



### I/O

#### 何为I/O

I/O即**输入/输出**

冯诺依曼型计算机分为：运算器、控制器、存储器、输入/输出

输入/输出设备可以是键盘、显示器、网卡、硬盘

输入设备向计算机输入数据，输出设备接收计算机输出的数据

**从计算机结构的视角，I/O描述了计算机系统与外部设备之间的通信过程**，一个进程的地址空间划分为**用户空间**和**内核空间**。用户空间不能直接访问内核空间，需要通过系统调用请求来访问内核空间

I/O主要有磁盘I/O（读写文件）和网络I/O（网络请求和响应）

当发生I/O调用时，通常由两个步骤：内核等待I/O设备准备好数据；内核将数据从内核空间拷贝到用户空间

常见的I/O模型有：**同步阻塞I/O**，**同步非阻塞I/O**，**I/O多路复用**，**信号驱动I/O**，**异步I/O**



#### Java中的BIO，NIO，AIO

##### BIO

同步阻塞I/O模式，数据的读写必须阻塞在一个线程内等待其完成。在客户端连接数量不是太多的情况之下，是没问题的。但是在面对十万甚至百万的连接的时候，传统的BIO模型是无能为力的。

应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间

<<<<<<< HEAD
<img src="image\同步阻塞.jpg" alt="image-20210405151345320" style="zoom: 25%;" />
=======
<img src="https://github.com/yzsjy/MarkDown/blob/main/image/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E.jpg" style="zoom:33%;" />
>>>>>>> 4901c50f8daf34c9e69bb27764eff3a0c8be4d1c

##### NIO

NIO是一种同步非阻塞I/O模式，于Java 1.4引入，对应`java.nio`包，提供了`Channel`，`Selector`，`Buffe`r等抽象。NIO中的N可以理解为Non-blocking，不是单纯的New。支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的`Socket`和`ServerSocket`相对应的`SocketChannel`和`ServerSocketChannel`两种不同的套接字通道实现，两种通道都支持阻塞与非阻塞两种模式。对于高负载、高并发（网络）应用，使用NIO的非阻塞模型开发

Java 中的 NIO 可以看作是 **I/O 多路复用模型**。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型

<img src="https://github.com/yzsjy/MarkDown/blob/main/image/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.jpg" style="zoom:33%;" />



##### AIO

异步非阻塞I/O，在Java 7中引入NIO的改进版本。异步I/O是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成后，操作系统会通知相应的线程进行后续的操作。



## 数据库原理

### 索引

#### 聚簇索引与非聚簇索引

索引在数据库中的作用相当于目录在书籍中的作用，提高查询的速度

##### 聚簇索引

聚簇索引就是存放的物理顺序和列中的顺序一样，一般主键索引就是聚簇索引。如果给表加上了主键，表在磁盘上的存储结构就由整齐的排列转换成为了树状结构，也就是平衡树结构。换句话说是整个表变成了一个索引。这就是为什么一个表只有一个主键以及只有一个聚簇索引，因为主键的作用就是把表的数据格式转换成索引。

叶子结点直接存放数据记录

##### 非聚簇索引

非聚簇索引采用平衡树作为索引的数据结构。索引树结构中各结点的值来自于表中的索引字段，假设给User表的name字段加上索引，索引就是由name字段中的值构成，在数据改变时，DBMS需要一直维护索引结构的正确性。如果给表中的多个字段加上索引，那么会存在多个索引表，每个索引结构之间没有关联。每次给一个字段建立索引表，字段中的数据就会被复制出一份，用于生成索引。

平衡树的叶子结点存放的时数据记录的地址。在检索索引时，先得到的是对应数据的地址，然后根据地址得到数据

两者区别在于：通过聚簇索引一次可以查到需要的数据，而非聚簇索引一次只能查到记录对应的主键值，在通过主键值通过聚簇索引找到需要的数据。

