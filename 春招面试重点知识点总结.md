# 春招面试重点知识点总结

## Java基础

### 重载和重写

重写多用于子类继承父类的方法，并对父类的方法进行了重新构造。返回值、参数列表和方法名必须完全相同，私有方法、final、static不可被重写，构造方法不可以被重写。

重载通俗来讲就是在相同的方法名下，有着不同的参数列表，即可以视为重载。

| 区别点     | 重载方法 | 重写方法                       |
| ---------- | -------- | ------------------------------ |
| 发生范围   | 同一个类 | 子类                           |
| 参数列表   | 必须修改 | 不能修改                       |
| 返回类型   | 可以修改 | 比父类范围更小或者相同         |
| 异常       | 可以修改 | 比父类范围更小或者相同         |
| 访问修饰符 | 可以修改 | 一定不能做严格限制，可降低限制 |
| 发生阶段   | 编译期   | 运行期                         |



### String, StringBuffer和StringBuilder的区别？String为什么是不可变的？

String类是使用final修饰的字符数组来表示字符串的，`private final char value[]`，所以String对象是不可变的。

StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder类中都是使用字符数组来保存字符串的，但没有final关键字修饰，所以这两个是可变的。

由于String是不可变的，所以是线程安全的。StringBuffer对方法或者调用的方法添加了同步锁，所以是线程安全的，而StringBuilder没有添加同步锁，所以不是线程安全的。

每次对String类型进行改变时都会生成一个新的String对象，而StringBuilder和StringBuffer都是在自身进行操作。

## JVM虚拟机

### Java对象引用算法

#### 引用计数算法

在对象中添加一个引用计数器，当有一个地方引用时，计数器值加一；当引用失效时，计数器值减一；计数器值为零时表示对象不可引用。该算法原理简单，判断高效，但可能不能结局例如对象之间互相循环引用的问。Java虚拟机不使用引用技术算法。

#### 可达性分析算法

该算法是当前主流程序语言判断对象存活的算法。通过一系列称为“GC Roots”的根对象作为起始结点集，从这个结点根据引用关系向下搜索，搜索过的路径称为引用链，若一个对象到GC Roots间没有任何引用链，则该对象不可在使用。

GC Roots对象可以是以下几种：

1. 虚拟机栈中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2. 在方法区中类静态属性引用的对象，例如Java类的引用类型静态变量
3. 在方法区中常量引用的对象，例如字符串常量池里的引用
4. 在本地方法栈中JNI（通常所说的Native方法）引用的对象
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NulPointException、OutOfMemeryError）等，还有系统类加载器
6. 所有被同步锁（synchronized关键字）持有的对象
7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

### Java对象创建过程

#### Step 1 类加载检查

虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先进行相应的类加载过程。

#### Step 2 分配内存

在类加载检查过后，接下来虚拟机为新创建的对象分配内存，所需大小在类加载过后就可以确认。为对象分配内存等同于将确定大小的内存从Java堆中取出来。分配方式有“指针碰撞”和“空闲列表”，选择哪种方式由Java堆是否规整决定，而Java堆是否规整由虚拟机采用的垃圾收集器是否带有压缩整理的功能决定。

内存分配的两种方式（指针碰撞和空闲列表）

|          | 指针碰撞                                                     | 空闲列表                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 适用场合 | 堆内存规整（即没有内存碎片）                                 | 堆内存不规整                                                 |
| 原理     | 用过的内存全部整理到一边，没用过的内存放在另一边，中间有一个分界指针，只需要向着没用到的内存方向将该指针移动到创建对象所需大小的位置就好 | 虚拟机会维护一个列表，该列表会记录哪个内存块是可用的，在分配的时候选取一块比所需内存大的块就好，最后更新列表 |
| GC收集器 | Serial，ParNew                                               | CMS                                                          |

内存分配并发问题

创建对象很重要的一件事是保证线程安全，通常采用两种方式来保证线程安全

CAS+失败重试：CAS是乐观锁的一种实现方式。每次不加锁而是假设完成操作时没有冲突，若发生冲突就失败重试，直到成功为止。这种方式保证了更新操作的原子性

TLAB：为每个线程预先在Eden区分配一块内存，JVM在给线程对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB中内存用尽时，在采取上述的CAS进行内存分配

#### Step 3 初始化零值

内存分配完成后，虚拟机需要将分配的内存空间初始化为零值（不包括对象头），这一步操作保证了对象在Java代码中不初始化就能直接使用，程序能够访问到这些字段的数据类型所对应的零值。

#### Step 4 设置对象头

初始化零值完成后，虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行的状态不同，如是否使用偏向锁等，对象头会有不同的设置方式。

#### Step 5 执行init方法

在上面工作都完成以后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚开始，<init>方法还没有执行，所有的字段都还是零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这时一个真正可用的对象才算完全产生出来。

## 计算机网络

### 网络层

#### IP数据报

![1](https://github.com/yzsjy/MarkDown/blob/main/image/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg)

**版本**：指IP的版本

**首部长度**：占4位

**总长度**：占16位，指首部和数据之和的长度，这个长度不能超过数据链路层的以太网帧的最大传送值（MTU）

**标识**：占16位，每产生一个数据报时就加1，数据报产生分片时要复制标识到每个分片

**标志**：占3位，最低位为MF，MF=1时表示后面还有分片，MF=0时表示为最后一个分片，中间位为DF，只有DF=0时才允许分片

**片偏移**：占13位，以8个字节为偏移单位，主要是让接收方利用片偏移将数据报分片重组

**首部校验和**：占16位，只校验首部

**生存时间（TTL）**：占8位，主要用来控制数据报经过路由的最大值，为0时要丢弃数据报

**协议**：占8位，主要告诉传输层运用哪种传输控制协议，6表示TCP，17表示UDP

**源地址字段**：占4B，表示发送方IP地址

**目的地址字段**：占4B，表示接收方IP地址



#### IP数据报分片

当一个IP数据报的最大数据量超过最大传送单元（MTU）时，就需要将IP数据报进行分片操作，分装在两个或更多的片中。片在目的地的网络层会被重新组装，利用IP数据报中的标识、标志、片偏移字段来完成对数据报的重组。



#### 网络层转发分组的流程

1. 从数据报的首部提取目的地址字段，得出目的网络地址N
2. 若网络地址N与当前路由相连，则把数据报直接交给目的地址主机，称为直接交付
3. 若路由表中有与网络地址N相连的特定路由，则将数据报交付给指明的下一跳路由
4. 若路由表没有到达N的路由，则把数据报传送给路由表指明的下一跳路由
5. 若路由表中有一个默认路由，则把数据报传送给路由表所指明的默认路由
6. 报告转发分组出错



#### IP地址的特点

每个IP地址都由网络号和主机号两部分组成，好处是IP地址管理机构只分配网络号而主机号由得到网络号的机构自行分配以及路由器只通过网络号来转发分组，从而减少了路由表所占的空间

IP地址是标志一台主机和一条链路的接口

用转发器或者桥接连接的若干LAN依然是同一个网络，因此该LAN中所有的主机IP的网络号都相同，而主机号不相同

在IP地址中，所有分配到的网络号的网络都是平等的

在同一个局域网上的主机和路由器的IP地址中的网络号必须是一样的，路由器的每个端口都有一个不同网络号的IP地址

### Https方式与服务器通信步骤

（1）客户端使用http的url访问服务端，请求与服务端建立ssl连接

（2）服务端收到建立连接请求后，将网站的证书信息（包含公钥）发送给客户端

（3）客户端与服务端协商ssl连接的安全等级，也就是信息加密等级

（4）客户端浏览器根同意的安全等级，建立会话密钥，使用服务端提供的公钥将会话密钥加密，发送给服务端

（5）服务端利用自己的私钥解析出会话密钥

（6）服务端利用会话密钥加密与客户端之间的通信



#### SSL/TLS协议建立详细过程

（1）客户端发送`clientHello`请求建立加密通信请求，包括客户端支持的SSL/TLS协议版本，客户端生产的随机数，客户端支持的加密格式

（2）服务端发送`serverHello`来响应客户端的请求，包括确认SSL/TLS的版本，若不支持则关闭连接；服务端生产的随机数，确认的加密格式以及服务端的CA数字证数

（3）客户端收到服务端的回应后，识别服务端的CA证书来确认证数是否有效，若有效则取出服务器的公钥，然后用公钥加密报文，向服务器发送

				1. 客户端随机数（经过公钥加密）
				2. 加密通信算法改变通知，即用会话密钥进行通信
				3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

（4）服务端收到客户端的协商请求后，通过协商的加密算法生成会话密钥，向客户端发送

1. 加密算法改变通知，表示以后发送信息都将采用会话密钥进行
2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验





## 操作系统

### 死锁

当两个或多于两个线程互相持有对方资源时，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才能释放资源，在此期间，其他线程不能访问代码块。当线程互相持有对方所需的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁

#### 死锁产生的条件

1. 互斥条件：进程对于所分配到的资源具有排他性，即一个资源只能被一个进程占用，直到该进程被释放
2. 请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放
3. 不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用
4. 循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路，造成永久阻塞



### I/O

#### 何为I/O

I/O即**输入/输出**

冯诺依曼型计算机分为：运算器、控制器、存储器、输入/输出

输入/输出设备可以是键盘、显示器、网卡、硬盘

输入设备向计算机输入数据，输出设备接收计算机输出的数据

**从计算机结构的视角，I/O描述了计算机系统与外部设备之间的通信过程**，一个进程的地址空间划分为**用户空间**和**内核空间**。用户空间不能直接访问内核空间，需要通过系统调用请求来访问内核空间

I/O主要有磁盘I/O（读写文件）和网络I/O（网络请求和响应）

当发生I/O调用时，通常由两个步骤：内核等待I/O设备准备好数据；内核将数据从内核空间拷贝到用户空间

常见的I/O模型有：**同步阻塞I/O**，**同步非阻塞I/O**，**I/O多路复用**，**信号驱动I/O**，**异步I/O**



#### Java中的BIO，NIO，AIO

##### BIO

同步阻塞I/O模式，数据的读写必须阻塞在一个线程内等待其完成。在客户端连接数量不是太多的情况之下，是没问题的。但是在面对十万甚至百万的连接的时候，传统的BIO模型是无能为力的。

应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间

<img src="https://github.com/yzsjy/MarkDown/blob/main/image/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E.jpg" style="zoom:33%;" />

##### NIO

NIO是一种同步非阻塞I/O模式，于Java 1.4引入，对应`java.nio`包，提供了`Channel`，`Selector`，`Buffe`r等抽象。NIO中的N可以理解为Non-blocking，不是单纯的New。支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的`Socket`和`ServerSocket`相对应的`SocketChannel`和`ServerSocketChannel`两种不同的套接字通道实现，两种通道都支持阻塞与非阻塞两种模式。对于高负载、高并发（网络）应用，使用NIO的非阻塞模型开发

Java 中的 NIO 可以看作是 **I/O 多路复用模型**。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型

<img src="https://github.com/yzsjy/MarkDown/blob/main/image/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.jpg" style="zoom:33%;" />



##### AIO

异步非阻塞I/O，在Java 7中引入NIO的改进版本。异步I/O是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成后，操作系统会通知相应的线程进行后续的操作。



## 数据库原理

### 索引

#### 聚簇索引与非聚簇索引

索引在数据库中的作用相当于目录在书籍中的作用，提高查询的速度

聚簇索引就是存放的物理顺序和列中的顺序一样，一般主键索引就是聚簇索引。如果给表加上了主键，表在磁盘上的存储结构就由整齐的排列转换成为了树状结构，也就是平衡树结构。换句话说是整个表变成了一个索引。这就是为什么一个表只有一个主键以及只有一个

