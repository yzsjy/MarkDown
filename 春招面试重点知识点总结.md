# 面试重点知识点总结

## Java基础

### 面向对象和面向过程

面向过程：**面向过程性能比面向对象的好**。因为类调用时需要实例化，开销比较大，比较消耗资源。

面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承和多态的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。

面向过程也需要分配内存，计算内存偏移量。Java性能差的主要原因使Java是半编译语言，最终执行代码并不是可以直接被CPU执行的二进制机械码



### Java语言的特点

简单易学

面向对象

平台无关性（Java虚拟机实现平台无关性）

可靠性

安全性

支持多线程

支持网络编程并且很方便（Java语言的诞生本身就是为简化网络编程设计的）

编译与解释并存



### 重载和重写

重写多用于子类继承父类的方法，并对父类的方法进行了重新构造。返回值、参数列表和方法名必须完全相同，私有方法、final、static不可被重写，构造方法不可以被重写。

重载通俗来讲就是在相同的方法名下，有着不同的参数列表，即可以视为重载。

| 区别点     | 重载方法 | 重写方法                       |
| ---------- | -------- | ------------------------------ |
| 发生范围   | 同一个类 | 子类                           |
| 参数列表   | 必须修改 | 不能修改                       |
| 返回类型   | 可以修改 | 比父类范围更小或者相同         |
| 异常       | 可以修改 | 比父类范围更小或者相同         |
| 访问修饰符 | 可以修改 | 一定不能做严格限制，可降低限制 |
| 发生阶段   | 编译期   | 运行期                         |



### String, StringBuffer和StringBuilder的区别？String为什么是不可变的？

String类是使用**final**修饰的字符数组来表示字符串的，`private final char value[]`，所以String对象是不可变的。

StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder类中都是使用字符数组来保存字符串的，但**没有final**关键字修饰，所以这两个是可变的。

由于String是不可变的，所以是线程安全的。StringBuffer对方法或者调用的方法添加了同步锁，所以是线程安全的，而StringBuilder没有添加同步锁，所以不是线程安全的。

每次对String类型进行改变时都会生成一个新的String对象，而StringBuilder和StringBuffer都是在自身进行操作。

### Java和C++的区别

都是面向对象的语言，都支持继承、多态和封装

Java不提供指针来直接访问内存，程序内存更加安全

Java的类是单继承，C++支持多重继承；Java的接口支持多重继承

Java有自动内存管理机制，不需要程序员手动释放无用的内存

在C语言中，字符串或者字符数组最后都会有一个额外的字符‘\0’来表示结束。但是Java语言中没有这个概念



### Java调用C/C++中的方法

需要使用Java调用本地方法，主要是使用JNI（Java Native Interface），JNI提供了若干的API实现了Java和其他语言的通信，主要是C/C++

JVM封装了各种操作系统的实际差异性的同时，提供了JNI技术，这是一个双向接口，使得开发者可以通过Java代码调用到各种Native的库，反之亦然。

作为一个双向接口，JNI能支持两种native代码：native libraries和native application

```
你能使用JNI去写一些native methods去允许Java applications能够呼叫native libraries中的函数，
native method的具体实现可能是C，C++或者Delphi
JNI支持嵌入一个JVM实现到一个本地应用程序中，去执行那些用Java语言编写的模块，比如一个C++编写的浏览器利用内嵌的JVM去执行下载到本地的applet
```

实现步骤

```
1. 完成Java代码，编写好Java的调用类
2. 编译你的Java类
3. 用javah生成编译好的class文件对应的C/C++函数的头文件
4. 实现头文件中的函数原型，编写native代码
5. 将native代码编译打包成DLL库（win32）或共享库（Linux）
6. 将你的Java代码跑起来
```



### 自动装箱和拆箱

装箱：将基本类型用它们对应的引用类型包装起来

拆箱：将包装类型转换成基本数据类型

### ArrayList和LinkedList的区别

1. 线程是否安全，ArrayList和LinkedList都不是同步的，也就是不保证线程安全的
2. 底层数据结构，ArrayList底层使用的是Object数组，LinkedList底层使用的是双向链表
3. 插入和删除操作是否受元素位置的影响，ArrayList采用数组存储，所以插入和删除元素的时间复杂度受到元素位置的影响；LinkedList采用链表存储，删除元素的时间复杂度不受元素位置的影响，如果在指定位置插入和删除元素的话，时间复杂度受到影响
4. 是否支持快速随机访问，LinkedList不支持高效的随机元素访问，而ArrayList支持
5. 内存空间占用，ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间，LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间

## JVM虚拟机

### Java对象引用算法

#### 引用计数算法

在对象中添加一个引用计数器，当有一个地方引用时，计数器值加一；当引用失效时，计数器值减一；计数器值为零时表示对象不可引用。该算法原理简单，判断高效，但可能不能结局例如对象之间互相循环引用的问。Java虚拟机不使用引用技术算法。

#### 可达性分析算法

该算法是当前主流程序语言判断对象存活的算法。通过一系列称为“GC Roots”的根对象作为起始结点集，从这个结点根据引用关系向下搜索，搜索过的路径称为引用链，若一个对象到GC Roots间没有任何引用链，则该对象不可在使用。

GC Roots对象可以是以下几种：

1. 虚拟机栈中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2. 在方法区中类静态属性引用的对象，例如Java类的引用类型静态变量
3. 在方法区中常量引用的对象，例如字符串常量池里的引用
4. 在本地方法栈中JNI（通常所说的Native方法）引用的对象
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NulPointException、OutOfMemeryError）等，还有系统类加载器
6. 所有被同步锁（synchronized关键字）持有的对象
7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等



### 垃圾回收

#### Full GC回收条件

当准备触发一次Young GC时，如果发现统计数据说之前Young GC的平均晋升大小比目前Old Gen剩余的空间大，则不会触发Young GC而是转而触发Full GC

如果有永久代，如果永久代分配的空间已经没有足够的空间了，也要触发一次Full GC

在调用诸如System.gc()、heap dump带GC，默认是触发Full GC

### Java对象创建过程

#### Step 1 类加载检查

虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先进行相应的类加载过程。

#### Step 2 分配内存

在类加载检查过后，接下来虚拟机为新创建的对象分配内存，所需大小在类加载过后就可以确认。为对象分配内存等同于将确定大小的内存从Java堆中取出来。分配方式有“指针碰撞”和“空闲列表”，选择哪种方式由Java堆是否规整决定，而Java堆是否规整由虚拟机采用的垃圾收集器是否带有压缩整理的功能决定。

内存分配的两种方式（指针碰撞和空闲列表）

|          | 指针碰撞                                                     | 空闲列表                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 适用场合 | 堆内存规整（即没有内存碎片）                                 | 堆内存不规整                                                 |
| 原理     | 用过的内存全部整理到一边，没用过的内存放在另一边，中间有一个分界指针，只需要向着没用到的内存方向将该指针移动到创建对象所需大小的位置就好 | 虚拟机会维护一个列表，该列表会记录哪个内存块是可用的，在分配的时候选取一块比所需内存大的块就好，最后更新列表 |
| GC收集器 | Serial，ParNew                                               | CMS                                                          |

内存分配并发问题

创建对象很重要的一件事是保证线程安全，通常采用两种方式来保证线程安全

CAS+失败重试：CAS是乐观锁的一种实现方式。每次不加锁而是假设完成操作时没有冲突，若发生冲突就失败重试，直到成功为止。这种方式保证了更新操作的原子性

TLAB：为每个线程预先在Eden区分配一块内存，JVM在给线程对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB中内存用尽时，在采取上述的CAS进行内存分配

#### Step 3 初始化零值

内存分配完成后，虚拟机需要将分配的内存空间初始化为零值（不包括对象头），这一步操作保证了对象在Java代码中不初始化就能直接使用，程序能够访问到这些字段的数据类型所对应的零值。

#### Step 4 设置对象头

初始化零值完成后，虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行的状态不同，如是否使用偏向锁等，对象头会有不同的设置方式。

#### Step 5 执行init方法

在上面工作都完成以后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚开始，<init>方法还没有执行，所有的字段都还是零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这时一个真正可用的对象才算完全产生出来。

### 类文件结构

#### JVM的无关性

平台无关性：任何操作系统都能运行Java代码

语言无关性：JVM能运行除Java以外的其他代码

Java源代码首先需要使用javac编译器编译成.class文件，然后由JVM执行.class文件，从而程序开始运行。JVM只认识.class文件，只要.class文件符合JVM的规范就能运行



#### Class文件结构

class文件是二进制文件，它的内容具有严格的规范，文件中没有空格，全部是连续的字节码，class文件所有内容被分为两种类型：

无符号数：无符号数表示class文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8分别表示1/2/4/8字节无符号数

表：由多个无符号数或者其他表作为数据项构成的复合数据类型



class文件具体由以下几个构成

魔数

版本信息

常量池

访问标志

类索引、父类索引、接口索引集合

字段表集合

方法表集合

属性表集合



##### 魔数

class文件头4个字节称为魔数，用来表示这个class文件的类型

魔数相当于文件的后缀名，只不过后缀名容易被修改，不安全，因此在class文件中标识文件类型比较合适

##### 版本信息

紧接着的4个字节是版本信息，5-6字节表示次版本号，7-8字节表示主版本号，它们表示当前class文件中使用的是哪个版本的jdk

高版本兼容低版本

##### 常量池

字面值常量：在程序中定义的字符串、被final修饰的值

符号引用：在程序中定义的各种名字，如类和接口的全限定名、字段的名字和描述符、方法的名字和描述符

##### 访问标志

2字节，这个标志用于识别一些类或者接口层次的访问信息，包括：这个class是类还是接口，是否定义为public类型，是否被abstract/final修饰

##### 类索引、父类索引、接口索引集合

类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，class文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名

由于Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Havana类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。一个类可能实现多个接口，因此用接口索引集合来描述。这个集合第一项为u2类型的数据，用来表示索引表的容量，接下来就是接口的名字索引

类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。

##### 字段表集合

字段表集合存储本类涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量

每个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。字段表结构如下

| 类型 | 名称             | 数量             | 说明                                                         |
| ---- | ---------------- | ---------------- | ------------------------------------------------------------ |
| u2   | access_flags     | 1                | 字段的访问标志，与类稍有不同                                 |
| u2   | name_index       | 1                | 字段名字的索引                                               |
| u2   | descriptor_index | 1                | 描述符，用于描述字段的数据类型。基本数据类型用大写字母表示；对象类型用”L对象类型的全限定名“表示 |
| u2   | attributes_count | 1                | 属性表集合的长度                                             |
| u2   | attributes       | attributes_count | 属性表集合，用于存放属性的额外信息，如属性的值               |



##### 方法表集合

方法表结构和属性表结构类似

volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有ACC_VOLATILE和ACC_TRANSIENT标志

方法表的属性表集合中有一张Code属性表，用于存储当前方法经编译器编译后的字节码指令

##### 属性表集合

| 类型 | 名称                 | 数量             |
| ---- | -------------------- | ---------------- |
| u2   | attribute_name_index | 1                |
| u4   | attribute_length     | 1                |
| u1   | info                 | attribute_length |



### 类加载的时机

以下情况需要立即执行类加载

（1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行初始化，则需要先触发其初始化阶段

（2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有初始化，需要先触发其初始化

（3）当初始化类的时候，如果发现其父类还没有初始化，则需要先初始化父类

（4）当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会优先初始化这个主类

（5）当使用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化

（6）当一个接口定义了默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化



### 类加载器

启动类加载器(Bootstrap Class Loader)：最顶层的加载类，负责加载Java目录下lib文件夹的jar包和`-Xbootclasspat`h参数指定的路径中的类

扩展类加载器：加载jre中lib/ext目录下的jar包，或者被`java.ext.dirs`系统变量所指定的路径

应用程序类加载器：面向我们用户的类加载器

#### 双亲委派模型

每一个类都有对应的类加载器，在类加载过程中默认使用双亲委派模型。在类加载过程中，首先会判定当前类是否被加载过，已经被加载的类会直接返回，否则首先会把该请求委派给父类加载器的`loadClass()`处理，所有的请求最终都会传输到顶层类加载器`BootstrapClassLoader`中。当父类无法加载请求时，才会自己来处理

#### 自定义类加载

如果不想打破双亲委派模型，就重写`ClassLoader`类中的findClass()方法即可，无法被父类加载器加载的类都会通过这个方法被加载。如果需要打破双亲委派模型就需要重写`loadClass()`方法。



### GC记录

为了严格监控应用程序的运行情况，我们应该始终检查JVM的垃圾回收性能。使用以下参数，我们能够记录GC活动：

```shell
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=< number of log files >
-XX:GClogFileSize=< file size >[ unit ]
-Xloggc:/path/to/gc.log
```



## Java并发

### Synchronized和ReentrantLock

#### 锁的实现

Synchronized锁是在jvm中实现的，ReentrantLock锁是在jdk中实现的

#### 性能

新版本的Java对Synchronized锁进行了很大优化，引入了自旋锁等概念，两者性能大致相同

#### 等待可中断

当持有锁的线程长期不释放锁的时候，等待的线程可以选择放弃等待，专为执行其他事务

ReentrantLock可中断，Synchronized锁不可中断

#### 公平锁

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的顺序来获取资源

Synchronized锁是非公平的，ReentrantLock锁也是非公平的，但也可以变为公平的

#### 锁绑定多个条件

一个ReentrantLock可以同时绑定多个Condition对象

#### 使用选择

除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 **JVM** 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 **JDK** 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。



### Thread类的几个常用方法

currentThread()：静态方法，返回当前正在执行的线程对象的引用

start()：开始执行线程的方法，Java虚拟机会调用线程内的run()方法

yield()：yield在英语中有放弃的意思，这里指当前线程愿意让出当前对处理器的占用，这里注意的是即使调用该方法，也还可能继续执行该线程

sleep()：静态方法，使当前线程睡眠一段时间

join()：使当前线程等待另一个线程执行完毕后在继续执行，内部调用的是Object类的wait方法来实现的

### Thread类和Runnable接口的比较

Java“单继承，多实现”的特性，Runnable接口使用比Thread类更加灵活

Runnable接口出现更符合面向对象，将线程单独进行对象的封装

Runnable接口出现，降低了线程对象和线程任务的耦合性

如果线程不需要使用Thread类的诸多方法，显然使用Runnable接口更加轻量



### 乐观锁与悲观锁

#### 区别

悲观锁：悲观锁认为每次访问共享资源时会发生冲突，所以每次必须对数据操作加上锁，以保证临界区的程序同一时间只有一个线程在执行

乐观锁：无锁，乐观锁认为每次访问共享资源时不会发生冲突，而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全，**乐观锁天然免疫死锁**

#### CAS

Compare And Swap，比较和交换

V：要更新的变量

E：预期值

N：新值

只有V的值等于E的值，才能用N的值替换V的值，反之则当前线程放弃更新

当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并允许再次尝试，当然也允许失败的线程放弃操作



### AQS

AbstractQueuedSynchronizer，抽象队列同步器

作用：构建锁和同步器的框架，能简单高效的构造出应用广泛的同步器，比如ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等

也可以自定义同步器，只要实现子类的几个protected方法就行

#### 数据结构



### 线程池

主要使用ThreadPoolExecutor创建线程池

主要参数有

corePoolSize：该线程池中核心线程数最大值

maximumPoolSize：该线程池中线程总数最大值

keepAliveTime：非核心线程闲置超时时长

TimeUnit：keepAliveTime的单位

workQueue：阻塞队列，维护着等待执行的Runnable任务对象



非必要参数有

threadFactory：创建线程工厂，用于批量创建线程，同一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会创建一个默认的线程工厂

handler：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，策略有

```txt
1. ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。
2. ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。
3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。
4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。
```





## 计算机网络

### 网络层

#### IP数据报

![1](https://github.com/yzsjy/MarkDown/blob/main/image/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg)

**版本**：指IP的版本

**首部长度**：占4位

**总长度**：占16位，指首部和数据之和的长度，这个长度不能超过数据链路层的以太网帧的最大传送值（MTU）

**标识**：占16位，每产生一个数据报时就加1，数据报产生分片时要复制标识到每个分片

**标志**：占3位，最低位为MF，MF=1时表示后面还有分片，MF=0时表示为最后一个分片，中间位为DF，只有DF=0时才允许分片

**片偏移**：占13位，以8个字节为偏移单位，主要是让接收方利用片偏移将数据报分片重组

**首部校验和**：占16位，只校验首部

**生存时间（TTL）**：占8位，主要用来控制数据报经过路由的最大值，为0时要丢弃数据报

**协议**：占8位，主要告诉传输层运用哪种传输控制协议，6表示TCP，17表示UDP

**源地址字段**：占4B，表示发送方IP地址

**目的地址字段**：占4B，表示接收方IP地址



#### IP数据报分片

当一个IP数据报的最大数据量超过最大传送单元（MTU）时，就需要将IP数据报进行分片操作，分装在两个或更多的片中。片在目的地的网络层会被重新组装，利用IP数据报中的标识、标志、片偏移字段来完成对数据报的重组。



#### 网络层转发分组的流程

1. 从数据报的首部提取目的地址字段，得出目的网络地址N
2. 若网络地址N与当前路由相连，则把数据报直接交给目的地址主机，称为直接交付
3. 若路由表中有与网络地址N相连的特定路由，则将数据报交付给指明的下一跳路由
4. 若路由表没有到达N的路由，则把数据报传送给路由表指明的下一跳路由
5. 若路由表中有一个默认路由，则把数据报传送给路由表所指明的默认路由
6. 报告转发分组出错



#### IP地址的特点

每个IP地址都由网络号和主机号两部分组成，好处是IP地址管理机构只分配网络号而主机号由得到网络号的机构自行分配以及路由器只通过网络号来转发分组，从而减少了路由表所占的空间

IP地址是标志一台主机和一条链路的接口

用转发器或者桥接连接的若干LAN依然是同一个网络，因此该LAN中所有的主机IP的网络号都相同，而主机号不相同

在IP地址中，所有分配到的网络号的网络都是平等的

在同一个局域网上的主机和路由器的IP地址中的网络号必须是一样的，路由器的每个端口都有一个不同网络号的IP地址



### Http和Https

#### 区别和联系

Http是超文本传输协议，传输的是明文信息，是不安全的；Https解决了Http的不安全传输，在TCP和Http网络层之间增加了SSL/TLS安全协议，保证了传输的安全性

Http传输建立相对简单，在TCP三次握手后便可进行传输；而Https在TCP三次握手的基础上加入了SSL/TLS的握手过程

Http使用的端口号为80，Https使用的端口号为443

Https协议需要向CA申请数字证书，来保证服务器的身份是可信的

Https通过SSL/TLS协议实现了信息加密、校验机制和身份证书，很好的解决了Http的窃听风险、篡改风险和冒充风险

#### Https的加密实现

信息加密解决窃听风险：采用混合加密的形式，在通信建立以前采用非对称加密的方式交换会话密钥，在建立通信以后采用对称加密的方式，通过会话密钥对明文进行加密

校验机制解决篡改风险：摘要算法能够为数据生成独一无二的指纹，用于校验数据的完整性，解决了篡改的风险。主要流程是通过在明文加密前绑定摘要，在接收端解密密文后利用摘要算法计算出摘要与明文绑定的摘要进行对比

身份证书解决冒充风险

### Https方式与服务器通信步骤

（1）客户端使用http的url访问服务端，请求与服务端建立ssl连接

（2）服务端收到建立连接请求后，将网站的证书信息（包含公钥）发送给客户端

（3）客户端与服务端协商ssl连接的安全等级，也就是信息加密等级

（4）客户端浏览器根同意的安全等级，建立会话密钥，使用服务端提供的公钥将会话密钥加密，发送给服务端

（5）服务端利用自己的私钥解析出会话密钥

（6）服务端利用会话密钥加密与客户端之间的通信



#### SSL/TLS协议建立详细过程

（1）客户端发送`clientHello`请求建立加密通信请求，包括客户端支持的SSL/TLS协议版本，客户端生产的随机数，客户端支持的加密格式

（2）服务端发送`serverHello`来响应客户端的请求，包括确认SSL/TLS的版本，若不支持则关闭连接；服务端生产的随机数，确认的加密格式以及服务端的CA数字证数

（3）客户端收到服务端的回应后，识别服务端的CA证书来确认证数是否有效，若有效则取出服务器的公钥，然后用公钥加密报文，向服务器发送

		1. 客户端随机数（经过公钥加密）
		2. 加密通信算法改变通知，即用会话密钥进行通信
		3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

第三步结束后用双方协商的加密算法，各自生成本次通信的会话密钥

（4）服务端收到客户端的协商请求后，通过协商的加密算法生成会话密钥，向客户端发送

```
	1. 加密算法改变通知，表示以后发送信息都将采用会话密钥进行
	2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验
```

至此整个SSL/TLS握手阶段全部结束， 接下来进行加密通信，利用会话密钥来加密内容



### Http/1.1、Http/2、Http/3演变

#### Http1.1相对于Http1.0的提升

使用TCP长连接的方式改善了1.0短连接造成的性能开销

支持管道网络传输，只要第一个请求发出去不需要等待其回来，就可以发出第二个请求，减少传输整体的响应时间

**不足：**

请求/响应头部未经压缩就发送，首部信息越多延迟就越大，从而延迟大以后只能压缩body部分

每次发送相同的首部造成浪费较多

服务器的响应顺序是按照请求顺序的，如果服务器响应慢，客户端会一直请求不到数据，造成队头阻塞

没有请求优先级控制

请求只能从客户端开始，服务器只能被动响应

#### Http2相对于Http1.1的提升

首先Http2是基于Https的，所以Http2的安全是有保障的

头部压缩：如果发送多个请求，如果他们的头部是一致或者相似的，协议会帮助消除重复的部分。采用HPACK算法，在两端同时维护一个头部信息表，所有字段都会存入这个表中，生成一个索引号，每次传输只发送索引号

二进制格式：不在采用之前的报文格式，全面采用二进制格式，头部信息和数据体都是二进制，称之为帧。提高效率

数据流：Http2中数据包不是按照顺序发送的，同一个连接里的连续数据包，可能属于不同的回应。因此必须对数据包做标记，指出其属于哪个回应。

多路复用：Http2可以在一个连接中并发多个请求或回应，不用按照顺序一一对应

服务器推送：服务器可以主动向客户端发送消息。例如在浏览器请求html的时候，就会提前把可能用到的js、css文件等静态资源主动发送给客户端，减少延迟等待

**不足：**

多个Http请求复用一个TCP连接，下层的TCP协议是不知道多少Http请求的，所以一旦发生丢包，就会触发TCP的重传机制，这样所有的Http请求都必须等待这个被丢失的包被重传回来

#### Http3相对于Http2的提升

Http3把Http下层的TCP协议改成了UDP

**如何实现UDP的可靠传输：**

采用QUIC协议实现UDP的可靠传输

QUIC有自己的一套机制可以保证传输的可靠性，当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响

TLS协议升级到了最新的1.3版本，头部压缩算法也升级成QPACK

QUIC直接把以往的TCP+TLS的6次交互合并成了3次，减少了交互次数



### TCP

#### 报文格式

确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答号后可以认为在这个序号以前的数据都已经被正常接收，用来解决不丢包的问题

序列号：在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小，用来解决网络包乱序的问题

#### 建立连接--三次握手

##### 具体流程

一开始，客户端和服务端都处于**CLOSED**状态。先是服务端主动监听某个端口，处于**LISTEN**状态

第一次握手：客户端会随机初始化序列号（client_isn），将此序号置于TCP首部的序号字段中，同时把SYN标志置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不会包括应用层数据，之后客户端处于**SYN-SENT**状态

第二次握手：服务端收到客户端的SYN报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入TCP首部的序号字段中，其次把TCP首部的确认应答号字段填入client_isn + 1，接着把SYN和ACK标志位置为1.最后把报文发送给客户端，该报文也不包含应用层数据，之后服务端处于**SYN-RCVD**状态

第三次握手：客户端收到服务端报文后，还要向服务端回应一个最后应答报文，首先该应答报文TCP首部ACK标志位置为1，其次确认应答号字段填入server_isn + 1，最后把报文发送给服务端，这次报文可以携带客户端到服务端的数据，之后客户端处于**ESTABLISHED**状态

服务端收到应答报文后，也进入**ESTABLISHED**状态



##### 为什么是三次握手

通常回答：因为三次握手才能保证双方都具有接收和发送的能力

三个原因：

1. 三次握手才能阻止重复历史连接的初始化（主要原因）
2. 三次握手才能同步双方的初始序列号
3. 三次握手才能避免资源的浪费

###### 原因一：避免历史连接





## 操作系统

### 死锁

当两个或多于两个线程互相持有对方资源时，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才能释放资源，在此期间，其他线程不能访问代码块。当线程互相持有对方所需的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁

#### 死锁产生的条件

1. 互斥条件：进程对于所分配到的资源具有排他性，即一个资源只能被一个进程占用，直到该进程被释放
2. 请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放
3. 不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用
4. 循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路，造成永久阻塞



### I/O

#### 何为I/O

I/O即**输入/输出**

冯诺依曼型计算机分为：运算器、控制器、存储器、输入/输出

输入/输出设备可以是键盘、显示器、网卡、硬盘

输入设备向计算机输入数据，输出设备接收计算机输出的数据

**从计算机结构的视角，I/O描述了计算机系统与外部设备之间的通信过程**，一个进程的地址空间划分为**用户空间**和**内核空间**。用户空间不能直接访问内核空间，需要通过系统调用请求来访问内核空间

I/O主要有磁盘I/O（读写文件）和网络I/O（网络请求和响应）

当发生I/O调用时，通常由两个步骤：内核等待I/O设备准备好数据；内核将数据从内核空间拷贝到用户空间

常见的I/O模型有：**同步阻塞I/O**，**同步非阻塞I/O**，**I/O多路复用**，**信号驱动I/O**，**异步I/O**



#### Java中的BIO，NIO，AIO

##### BIO

同步阻塞I/O模式，数据的读写必须阻塞在一个线程内等待其完成。在客户端连接数量不是太多的情况之下，是没问题的。但是在面对十万甚至百万的连接的时候，传统的BIO模型是无能为力的。

应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间



##### NIO

NIO是一种同步非阻塞I/O模式，于Java 1.4引入，对应`java.nio`包，提供了`Channel`，`Selector`，`Buffe`r等抽象。NIO中的N可以理解为Non-blocking，不是单纯的New。支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的`Socket`和`ServerSocket`相对应的`SocketChannel`和`ServerSocketChannel`两种不同的套接字通道实现，两种通道都支持阻塞与非阻塞两种模式。对于高负载、高并发（网络）应用，使用NIO的非阻塞模型开发

Java 中的 NIO 可以看作是 **I/O 多路复用模型**。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型



##### AIO

异步非阻塞I/O，在Java 7中引入NIO的改进版本。异步I/O是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成后，操作系统会通知相应的线程进行后续的操作。

### 阻塞与非阻塞I/O VS 同步与异步I/O

阻塞等待的是**内核数据准备好**和**数据从内核态拷贝到用户态**这两个过程

无论是阻塞I/O、非阻塞I/O，还是基于非阻塞I/O的多路复用都是同步调用。因为它们在read调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read调用就会在这个同步过程中等待比较长的时间

异步I/O是**内核数据准备好**和**数据从内核态拷贝到用户态**这两个过程都不用等待

## 数据库原理

### 索引

#### 使用B-Tree作为数据结构的好处

有更低的树高，使访问速度更快

树上的每个节点在磁盘上都是完整存储的，所以在磁盘上的读取速度更快

因为叶子节点都在同一层，可以预先载入相邻的节点

#### 聚簇索引与非聚簇索引

索引在数据库中的作用相当于目录在书籍中的作用，提高查询的速度

##### 聚簇索引

聚簇索引就是存放的物理顺序和列中的顺序一样，一般主键索引就是聚簇索引。如果给表加上了主键，表在磁盘上的存储结构就由整齐的排列转换成为了树状结构，也就是平衡树结构。换句话说是整个表变成了一个索引。这就是为什么一个表只有一个主键以及只有一个聚簇索引，因为主键的作用就是把表的数据格式转换成索引。

叶子结点直接存放数据记录

##### 非聚簇索引

非聚簇索引采用平衡树作为索引的数据结构。索引树结构中各结点的值来自于表中的索引字段，假设给User表的name字段加上索引，索引就是由name字段中的值构成，在数据改变时，DBMS需要一直维护索引结构的正确性。如果给表中的多个字段加上索引，那么会存在多个索引表，每个索引结构之间没有关联。每次给一个字段建立索引表，字段中的数据就会被复制出一份，用于生成索引。

平衡树的叶子结点存放的时数据记录的地址。在检索索引时，先得到的是对应数据的地址，然后根据地址得到数据

两者区别在于：通过聚簇索引一次可以查到需要的数据，而非聚簇索引一次只能查到记录对应的主键值，在通过主键值通过聚簇索引找到需要的数据。



## Spring

### Spring特征

核心技术、测试、数据访问、Web支持、集成、语言



### Spring核心模块

Spring Core：spring其他所有功能都需要依赖于该类库。主要提供IOC依赖注入功能

Spring Aspects：与AspectJ集成提供支持

Spring AOP：提供面向切面编程实现

Spring JDBC：Java数据库连接

Spring JMS：Java消息服务

Spring ORM：用于支持Hibernate等持久层框架

Spring Web：为创建web应用程序提供支持

Spring Test：提供了对JUnit和TestNG测试的支持



### IOC

控制反转（Inverse of Control），是一个设计思想。就是将原本在程序中手动创建对象的控制权，交由spring框架管理。IOC容器是spring用来实现IOC的载体。

将对象之间的相互依赖关系交给IOC容器来管理，并由IOC容器完成对象的注入。IOC容器就像一个工厂一样，当我们需要创建一个对象时，只需要配置好配置文件/注解即可，完全不用考虑对象时如何被创建的

**XML -> Resource -> BeanDefinition -> BeanFactory**



### AOP

面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑或者责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性

AOP基于动态代理，如果要代理对象，实现了某个接口，AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候spring AOP会使用Cglib，这时候spring AOP会使用Cglib生成一个被代理对象的子类来作为代理



## MySql

### 字符串类型CHAR和VARCHAR的区别

CHAR是定长的，VARCHAR是变长的

在进行存储和检索时，会保留VARCHAR末尾的空格，而会删除CHAR末尾的空格

VARCHAR这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行UPDATE时可能会使行变得比原来长，当超出一个页能容纳的大小时，就要执行额外的操作。MyISAM会将行拆分成不同的片段存储，而InnoDB则需要分裂页来使行放进页内